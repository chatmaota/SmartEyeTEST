<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SmartEye HUD | JARVIS Industrial Print Inspection</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root{
      --bg0:#02040c; --bg1:#050b1a;
      --hud:#00e5ff; --hud2:#5cffc9;
      --warn:#ff3b3b;
      --txt:#eaf6ff; --dim:rgba(234,246,255,.55);
      --panel: rgba(8,18,46,.45);
      --shadow: rgba(0,0,0,.55);
    }

    body{
      color: var(--txt);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(0,229,255,.16), transparent 60%),
        radial-gradient(900px 600px at 85% 25%, rgba(92,255,201,.10), transparent 55%),
        radial-gradient(900px 600px at 70% 85%, rgba(255,59,59,.08), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      position: relative;
      overflow-x: hidden;
      min-height: 100vh;
    }

    body::before{
      content:"";
      position: fixed; inset:0;
      pointer-events:none;
      background:
        linear-gradient(rgba(0,229,255,.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,229,255,.06) 1px, transparent 1px);
      background-size: 42px 42px;
      opacity:.22;
      mix-blend-mode: screen;
      z-index: 0;
    }
    body::after{
      content:"";
      position: fixed; inset:-30%;
      pointer-events:none;
      background: linear-gradient(180deg, transparent, rgba(0,229,255,.10), transparent);
      animation: scan 7s linear infinite;
      opacity:.35;
      mix-blend-mode: screen;
      z-index: 0;
    }
    @keyframes scan{
      0%{ transform: translateY(-40%); }
      100%{ transform: translateY(40%); }
    }

    .hud-panel{
      background: var(--panel);
      border: 1px solid rgba(0,229,255,.18);
      box-shadow: 0 24px 70px var(--shadow), 0 0 0 1px rgba(92,255,201,.06) inset;
      backdrop-filter: blur(10px);
      border-radius: 18px;
      position: relative;
      z-index: 1;
    }
    .hud-title{
      letter-spacing: .22em;
      text-transform: uppercase;
      font-weight: 800;
      color: rgba(234,246,255,.85);
    }
    .hud-glow{
      box-shadow:
        0 0 0 1px rgba(0,229,255,.25),
        0 0 32px rgba(0,229,255,.16),
        0 0 58px rgba(92,255,201,.08);
    }
    .hud-corners{ position: relative; }
    .hud-corners:before,
    .hud-corners:after{
      content:"";
      position:absolute; inset:10px;
      border: 1px dashed rgba(0,229,255,.22);
      border-radius: 16px;
      pointer-events:none;
      opacity:.55;
    }
    .hud-corners:after{
      inset:18px;
      border-color: rgba(92,255,201,.12);
      opacity:.45;
    }
    .hud-mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing: .08em;
      color: var(--dim);
    }

    .btn-jarvis{
      background: linear-gradient(180deg, rgba(0,229,255,.22), rgba(0,229,255,.06));
      border: 1px solid rgba(0,229,255,.32);
      color: rgba(234,246,255,.92);
      font-weight: 800;
      border-radius: 14px;
      padding: 10px 14px;
      transition: .15s;
      box-shadow: 0 12px 28px rgba(0,0,0,.35), 0 0 22px rgba(0,229,255,.12);
    }
    .btn-jarvis:hover{ transform: translateY(-1px); filter: brightness(1.15); }
    .btn-jarvis.warn{
      border-color: rgba(255,59,59,.4);
      background: linear-gradient(180deg, rgba(255,59,59,.20), rgba(255,59,59,.06));
    }

    input[type="range"]{
      -webkit-appearance: none; appearance:none;
      height: 6px; border-radius: 999px;
      background: linear-gradient(90deg, rgba(0,229,255,.85), rgba(92,255,201,.70));
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width: 18px; height: 18px; border-radius: 999px;
      background: rgba(234,246,255,.95);
      border: 2px solid rgba(0,229,255,.8);
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
      cursor: pointer;
    }

    .toggle{
      width: 42px; height: 24px; border-radius: 999px;
      background: rgba(234,246,255,.15);
      position: relative; transition: .2s;
      border: 1px solid rgba(255,255,255,.10);
    }
    .toggle::after{
      content:""; position:absolute; top: 3px; left: 3px;
      width: 18px; height: 18px; border-radius: 999px;
      background: rgba(234,246,255,.95);
      transition: .2s;
    }
    input:checked + .toggle{
      background: rgba(0,229,255,.35);
      box-shadow: 0 0 20px rgba(0,229,255,.22);
    }
    input:checked + .toggle::after{ left: 21px; }

    .dropzone{
      border: 1px dashed rgba(234,246,255,.22);
      background: rgba(8,18,46,.55);
      border-radius: 18px;
    }

    .hud-ring{
      width: 160px; height: 160px;
      border-radius: 999px;
      position: relative;
      background:
        radial-gradient(circle at 50% 50%, rgba(0,229,255,.20), transparent 55%),
        conic-gradient(from 210deg,
          rgba(0,229,255,.0) 0deg,
          rgba(0,229,255,.85) 55deg,
          rgba(92,255,201,.55) 120deg,
          rgba(0,229,255,.0) 180deg,
          rgba(0,229,255,.40) 270deg,
          rgba(0,229,255,.0) 360deg);
      box-shadow: 0 0 0 1px rgba(0,229,255,.25), 0 0 35px rgba(0,229,255,.12);
      overflow: hidden;
    }
    .hud-ring:before{
      content:""; position:absolute; inset:16px;
      border-radius: 999px;
      border: 1px solid rgba(0,229,255,.28);
    }
    .hud-ring:after{
      content:""; position:absolute; inset:38px;
      border-radius: 999px;
      border: 1px dashed rgba(92,255,201,.18);
      opacity:.8;
    }
    .hud-ring .spin{
      position:absolute; inset:-10px;
      border-radius: 999px;
      border: 2px solid rgba(0,229,255,.22);
      border-left-color: transparent;
      border-right-color: transparent;
      animation: spin 6s linear infinite;
      opacity:.6;
    }
    @keyframes spin{ to{ transform: rotate(360deg);} }

    /* stage */
    .media-stage{
      position: relative;
      width: 100%;
      height: 100%;
      user-select: none;
    }
    .media-stage video,
    .media-stage img{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit: contain;
    }
    .media-stage video{ display:none; }

    .roi-box{
      position:absolute;
      border: 2px solid rgba(0,255,255,.9);
      border-radius: 10px;
      background: rgba(0,255,255,.08);
      display:none;
      cursor: move;
      box-shadow: 0 0 24px rgba(0,229,255,.18);
    }
    .roi-box.yellow{
      border-color: rgba(255,230,0,.9);
      background: rgba(255,230,0,.08);
      box-shadow: 0 0 24px rgba(255,230,0,.12);
    }
    .roi-hint{
      position:absolute; bottom: 10px; left: 12px;
      font-size: 12px;
      color: rgba(234,246,255,.65);
      background: rgba(0,0,0,.25);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      pointer-events:none;
    }
    .draw-cursor{ cursor: crosshair !important; }

    /* overlay canvas layer */
    .ov-layer{
      position:absolute; inset:0 indicating: 0;
      width:100%; height:100%;
      pointer-events:none;
      mix-blend-mode: screen;
      opacity: .95;
    }

    /* small input */
    .hud-input{
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(0,229,255,.22);
      border-radius: 12px;
      padding: 8px 10px;
      color: rgba(234,246,255,.92);
      outline: none;
    }
    .hud-input::placeholder{ color: rgba(234,246,255,.38); }
  </style>
</head>

<body>
  <!-- HEADER -->
  <header class="px-6 py-4">
    <div class="hud-panel hud-glow hud-corners px-5 py-4 flex items-center justify-between gap-6">
      <div class="flex items-center gap-4">
        <div class="hud-ring"><div class="spin"></div></div>
        <div>
          <div class="text-xl font-extrabold tracking-wide">SMART EYE ¬∑ HUD</div>
          <div class="hud-mono text-xs mt-1">SYSTEM: ONLINE ¬∑ SECURE LINK: OK ¬∑ FPS: <span id="fpsText">--</span></div>
          <div class="hud-mono text-xs mt-1">INSPECTOR: PRINT ¬∑ MODEL: v1.0 ¬∑ PIPELINE: READY</div>
        </div>
      </div>

      <div class="text-right">
        <div class="hud-title text-xs">CAMERA STATUS</div>
        <div id="camStatus" class="text-sm font-extrabold text-cyan-200">FREE</div>
        <div class="hud-mono text-xs mt-1">NODE: INSPECT-01 ¬∑ MODE: <span id="modeText">CAPTURE</span></div>
        <div class="hud-mono text-xs mt-1" id="permHint">PERMISSION: UNKNOWN</div>
      </div>
    </div>
  </header>

  <!-- MAIN -->
  <main class="px-6 pb-8">
    <div class="grid grid-cols-12 gap-5">
      <!-- LEFT CONTROL -->
      <aside class="col-span-12 lg:col-span-4 xl:col-span-3">
        <div class="hud-panel hud-corners p-4">
          <div class="flex items-center justify-between mb-3">
            <div class="hud-title text-xs">CONTROL MATRIX</div>
            <div class="hud-mono text-xs">v1.0 JARVIS THEME</div>
          </div>

          <button id="btnCompare" class="btn-jarvis w-full">üîç ANALYZE / COMPARE</button>
          <button id="btnExport" class="btn-jarvis w-full mt-3">üìÑ EXPORT REPORT</button>
          <button id="btnReset" class="btn-jarvis w-full mt-3 warn">üßπ RESET</button>

          <div class="mt-5">
            <div class="hud-title text-xs mb-2">DIAGNOSTICS</div>
            <div class="hud-mono text-xs">DIFF: <span id="diffText">--</span>%</div>
            <div class="hud-mono text-xs mt-1">DIFF (SMOOTH): <span id="diffSmoothText">--</span>%</div>
            <div class="hud-mono text-xs mt-1">RESULT: <span id="resultText">-</span></div>
            <div class="hud-mono text-xs mt-1">THR: <span id="thrText">--</span></div>
            <div class="hud-mono text-xs mt-1">ALIGN: <span id="alignText">dx=0 dy=0</span></div>
          </div>

          <!-- MODE -->
          <div class="mt-5 hud-panel p-4">
            <div class="hud-title text-xs mb-3">MODE</div>
            <label class="flex items-center gap-3 cursor-pointer py-1">
              <input type="radio" name="mode" value="capture" checked class="accent-cyan-300"/>
              <span class="text-sm">Compare Capture</span>
            </label>
            <label class="flex items-center gap-3 cursor-pointer py-1">
              <input type="radio" name="mode" value="realtime" class="accent-cyan-300"/>
              <span class="text-sm">Compare Realtime (Live on Picture 2)</span>
            </label>
          </div>

          <!-- ROI CONTROL -->
          <div class="mt-4 hud-panel p-4">
            <div class="hud-title text-xs mb-3">ROI CONTROL</div>

            <label class="flex items-center gap-3 cursor-pointer py-1">
              <input type="radio" name="roiMode" value="auto" checked class="accent-cyan-300"/>
              <span class="text-sm">Auto ROI (Program)</span>
            </label>
            <label class="flex items-center gap-3 cursor-pointer py-1">
              <input type="radio" name="roiMode" value="custom" class="accent-cyan-300"/>
              <span class="text-sm">Custom ROI (Drag to select)</span>
            </label>

            <div class="mt-3 flex items-center justify-between">
              <div class="text-sm font-semibold">Enable ROI</div>
              <label class="flex items-center gap-3 cursor-pointer">
                <input id="toggleROI" type="checkbox" checked class="hidden"/>
                <span class="toggle"></span>
              </label>
            </div>

            <div class="mt-3 flex items-center justify-between">
              <div class="text-sm font-semibold">Lock ROI Size</div>
              <label class="flex items-center gap-3 cursor-pointer">
                <input id="toggleLockROI" type="checkbox" class="hidden"/>
                <span class="toggle"></span>
              </label>
            </div>

            <button id="btnCopyROI12" class="btn-jarvis w-full mt-3">üìê COPY ROI1 ‚Üí ROI2 (SIZE)</button>

            <div class="mt-3 hud-mono text-xs">ROI1: <span id="roi1Text" class="text-white/90">-</span></div>
            <div class="mt-1 hud-mono text-xs">ROI2: <span id="roi2Text" class="text-white/90">-</span></div>
            <div class="mt-2 hud-mono text-[11px]">Tip: Lock ON ‚Üí ‡∏Ç‡∏¢‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß (‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î)</div>
          </div>

          <!-- SETTINGS -->
          <div class="mt-4 hud-panel p-4 space-y-4">
            <div class="hud-title text-xs">INSPECTION SETTINGS</div>

            <div>
              <div class="flex items-center justify-between">
                <div class="hud-mono text-[11px]">FAIL LIMIT</div>
                <div class="hud-mono text-[11px] text-white/90" id="failVal">10.0%</div>
              </div>
              <input id="failRange" type="range" min="1" max="60" value="10" class="w-full mt-2"/>
            </div>

            <div>
              <div class="flex items-center justify-between">
                <div class="hud-mono text-[11px]">SENSITIVITY</div>
                <div class="hud-mono text-[11px] text-white/90" id="sensVal">60%</div>
              </div>
              <input id="sensRange" type="range" min="0" max="100" value="60" class="w-full mt-2"/>
            </div>

            <div>
              <div class="flex items-center justify-between">
                <div class="hud-mono text-[11px]">SMOOTH (FRAMES)</div>
                <div class="hud-mono text-[11px] text-white/90" id="smoothVal">8</div>
              </div>
              <input id="smoothRange" type="range" min="1" max="20" value="8" class="w-full mt-2"/>
            </div>

            <div class="flex items-center justify-between">
              <div class="text-sm font-semibold">Heatmap Overlay</div>
              <label class="flex items-center gap-3 cursor-pointer">
                <input id="toggleHeatmap" type="checkbox" checked class="hidden"/>
                <span class="toggle"></span>
              </label>
            </div>

            <div class="flex items-center justify-between">
              <div class="text-sm font-semibold">Auto Align (dx/dy)</div>
              <label class="flex items-center gap-3 cursor-pointer">
                <input id="toggleAlign" type="checkbox" checked class="hidden"/>
                <span class="toggle"></span>
              </label>
            </div>

            <div>
              <div class="flex items-center justify-between">
                <div class="hud-mono text-[11px]">ALIGN RANGE (px)</div>
                <div class="hud-mono text-[11px] text-white/90" id="alignRangeVal">8</div>
              </div>
              <input id="alignRange" type="range" min="0" max="20" value="8" class="w-full mt-2"/>
            </div>

            <div class="flex items-center justify-between">
              <div class="text-sm font-semibold">Show Defect Overlay</div>
              <label class="flex items-center gap-3 cursor-pointer">
                <input id="toggleOverlay" type="checkbox" checked class="hidden"/>
                <span class="toggle"></span>
              </label>
            </div>
          </div>

          <!-- PRESET -->
          <div class="mt-4 hud-panel p-4">
            <div class="hud-title text-xs mb-3">ROI PRESET (MACHINE / JOB / CUSTOMER)</div>
            <input id="presetKey" class="hud-input w-full" placeholder="‡πÄ‡∏ä‡πà‡∏ô: TCRB-COR1 | JOB123 | ABC" />
            <div class="grid grid-cols-3 gap-2 mt-3">
              <button id="btnPresetSave" class="btn-jarvis w-full">üíæ SAVE</button>
              <button id="btnPresetLoad" class="btn-jarvis w-full">üì• LOAD</button>
              <button id="btnPresetDel"  class="btn-jarvis w-full warn">üóëÔ∏è DEL</button>
            </div>
            <div class="hud-mono text-xs mt-3" id="presetMsg">-</div>
          </div>

          <!-- PERMISSION -->
          <div class="mt-4 hud-panel p-4">
            <div class="hud-title text-xs mb-2">PERMISSION CHECK</div>
            <div class="hud-mono text-xs" id="permText">Camera: checking...</div>
          </div>
        </div>
      </aside>

      <!-- RIGHT -->
      <section class="col-span-12 lg:col-span-8 xl:col-span-9">
        <div class="grid grid-cols-1 xl:grid-cols-2 gap-5">

          <!-- Picture 1 -->
          <div class="hud-panel hud-corners p-4">
            <div class="flex items-center justify-between mb-3">
              <div class="hud-title text-xs">PICTURE 1 (BASE)</div>
              <div class="hud-mono text-xs">VIEW 640√ó420</div>
            </div>

            <div class="dropzone p-3">
              <div class="aspect-[640/420] w-full rounded-xl overflow-hidden bg-[#07102a] relative">
                <div id="stage1" class="media-stage">
                  <video id="vid1" playsinline autoplay muted></video>
                  <img id="img1" alt="" />
                  <div id="roi1" class="roi-box"></div>
                  <div class="roi-hint">Custom ROI: ‡∏•‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‚Ä¢ ‡∏•‡∏≤‡∏Å‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡πâ‡∏≤‡∏¢</div>
                </div>
              </div>

              <div class="mt-3 grid grid-cols-3 gap-2">
                <button id="openCam1" class="btn-jarvis w-full">üì∑ OPEN</button>
                <button id="cap1" class="btn-jarvis w-full">üì∏ CAPTURE</button>
                <label class="btn-jarvis w-full text-center cursor-pointer">
                  üìÇ UPLOAD
                  <input type="file" accept="image/*" class="hidden" id="up1" />
                </label>
              </div>
            </div>
          </div>

          <!-- Picture 2 -->
          <div class="hud-panel hud-corners p-4">
            <div class="flex items-center justify-between mb-3">
              <div class="hud-title text-xs">PICTURE 2 (LIVE / TARGET)</div>
              <div class="hud-mono text-xs">VIEW 640√ó420</div>
            </div>

            <div class="dropzone p-3">
              <div class="aspect-[640/420] w-full rounded-xl overflow-hidden bg-[#07102a] relative">
                <div id="stage2" class="media-stage">
                  <video id="vid2" playsinline autoplay muted></video>
                  <img id="img2" alt="" />
                  <div id="roi2" class="roi-box yellow"></div>
                  <canvas id="ov2" class="ov-layer"></canvas>
                  <div class="roi-hint">Realtime: overlay + heatmap ‚Ä¢ Custom ROI ‡πÉ‡∏ä‡πâ ROI2</div>
                </div>
              </div>

              <div class="mt-3 grid grid-cols-3 gap-2">
                <button id="openCam2" class="btn-jarvis w-full">üì∑ OPEN</button>
                <ÂëäËØâ id="cap2" class="btn-jarvis w-full">üì∏ CAPTURE</button>
                <label class="btn-jarvis w-full text-center cursor-pointer">
                  üìÇ UPLOAD
                  <input type="file" accept="image/*" class="hidden" id="up2" />
                </label>
              </div>
            </div>
          </div>
        </div>

        <div class="mt-5 hud-mono text-xs">
          * ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ <span class="text-white/90">getUserMedia()</span> ‚Üí ‡∏ï‡πâ‡∏≠‡∏á https ‡πÅ‡∏•‡∏∞ Allow camera
        </div>
      </section>
    </div>
  </main>

  <canvas id="capCanvas" class="hidden"></canvas>

  <script>
    // ===========================
    //  Utilities
    // ===========================
    const $ = (id)=>document.getElementById(id);
    const nowStamp = ()=> new Date().toISOString().replace('T',' ').replace(/\..+/,'');

    function thrFromSensitivity(sens){
      sens = Math.max(0, Math.min(100, sens|0));
      // 0% -> 90, 100% -> 10 (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÅ‡∏ô‡∏ß python ‡πÄ‡∏î‡∏¥‡∏°)
      const thr = Math.round(90 + (10-90) * (sens/100));
      return Math.max(1, thr);
    }

    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

    // contain-rect mapping for object-fit:contain (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Å‡∏±‡∏ö ROI)
    function getContainRect(stageW, stageH, mediaW, mediaH){
      const stageAR = stageW / stageH;
      const mediaAR = mediaW / mediaH;
      let drawW, drawH, offX, offY;

      if(mediaAR > stageAR){
        drawW = stageW;
        drawH = stageW / mediaAR;
        offX = 0;
        offY = (stageH - drawH) / 2;
      }else{
        drawH = stageH;
        drawW = stageH * mediaAR;
        offY = 0;
        offX = (stageW - drawW) / 2;
      }
      return {offX, offY, drawW, drawH};
    }

    function stageRoiToMediaRoi(stageEl, roiPx, mediaW, mediaH){
      const r = stageEl.getBoundingClientRect();
      const {offX, offY, drawW, drawH} = getContainRect(r.width, r.height, mediaW, mediaH);

      const x1 = Math.max(roiPx.x, offX);
      const y1 = Math.max(roiPx.y, offY);
      const x2 = Math.min(roiPx.x + roiPx.w, offX + drawW);
      const y2 = Math.min(roiPx.y + roiPx.h, offY + drawH);

      const cw = Math.max(1, x2 - x1);
      const ch = Math.max(1, y2 - y1);

      const mx = ((x1 - offX) / drawW) * mediaW;
      const my = ((y1 - offY) / drawH) * mediaH;
      const mw = (cw / drawW) * mediaW;
      const mh = (ch / drawH) * mediaH;

      return {mx, my, mw, mh};
    }

    function setModeText(){
      const v = document.querySelector('input[name="mode"]:checked')?.value || "capture";
      $("modeText").textContent = (v === "realtime") ? "REALTIME" : "CAPTURE";
    }

    // ===========================
    //  Camera
    // ===========================
    const streams = {1:null, 2:null};

    function setCamStatus(isBusy, owner){
      if(!isBusy){
        $("camStatus").textContent = "FREE";
        $("camStatus").className = "text-sm font-extrabold text-cyan-200";
      }else{
        $("camStatus").textContent = `BUSY (P${owner})`;
        $("camStatus").className = "text-sm font-extrabold text-red-300";
      }
    }

    async function openCamera(which){
      try{
        stopCamera(which);
        setCamStatus(true, which);

        const constraints = {
          video: {
            facingMode: "environment",
            width: { ideal: 1280 },
            height:{ ideal: 720 }
          },
          audio: false
        };

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        streams[which] = stream;

        const vid = which===1 ? $("vid1") : $("vid2");
        vid.srcObject = stream;
        vid.style.display = "block";

        const img = which===1 ? $("img1") : $("img2");
        img.style.opacity = "0";

      }catch(err){
        setCamStatus(false);
        console.error("openCamera error:", err);
        const map = {
          NotAllowedError: "‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï Camera (‡πÇ‡∏î‡∏ô Block ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ Allow)",
          NotFoundError: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á (‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î/‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö)",
          NotReadableError: "‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏ä‡πâ‡∏≠‡∏¢‡∏π‡πà (Zoom/Teams/OBS)",
          OverconstrainedError: "‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏π‡∏á‡πÄ‡∏Å‡∏¥‡∏ô (constraints ‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô)"
        };
        alert(`‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${map[err.name] || err.name}\n\n‡∏•‡∏≠‡∏á‡∏ó‡∏≥:\n1) ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏Å‡∏∏‡∏ç‡πÅ‡∏à‡∏´‡∏ô‡πâ‡∏≤ URL ‚Üí Camera ‚Üí Allow\n2) ‡∏õ‡∏¥‡∏î‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á\n3) Reload ‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà`);
      }
    }

    function stopCamera(which){
      const stream = streams[which];
      if(stream){
        stream.getTracks().forEach(t=>t.stop());
        streams[which] = null;
      }
      const vid = which===1 ? $("vid1") : $("vid2");
      vid.style.display = "none";
      vid.srcObject = null;
      setCamStatus(false);
    }

    function captureFrame(which){
      const vid = which===1 ? $("vid1") : $("vid2");
      if(!streams[which] || vid.style.display==="none"){
        alert("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á\n‡∏Å‡∏î OPEN ‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö");
        return;
      }

      const c = $("capCanvas");
      c.width = vid.videoWidth || 1280;
      c.height = vid.videoHeight || 720;
      const ctx = c.getContext("2d");
      ctx.drawImage(vid, 0, 0, c.width, c.height);

      const dataUrl = c.toDataURL("image/png");
      const img = which===1 ? $("img1") : $("img2");
      img.src = dataUrl;
      img.style.opacity = "1";
    }

    function loadLocalImage(file, which){
      if(!file) return;
      const url = URL.createObjectURL(file);
      const img = which===1 ? $("img1") : $("img2");
      img.src = url;
      img.style.opacity = "1";
      stopCamera(which);
    }

    // ===========================
    //  ROI (draw + move + lock size)
    // ===========================
    const roiState = {
      1: { active:false, drawing:false, moving:false, x:0,y:0,w:0,h:0, startX:0,startY:0, moveDX:0, moveDY:0 },
      2: { active:false, drawing:false, moving:false, x:0,y:0,w:0,h:0, startX:0,startY:0, moveDX:0, moveDY:0 }
    };

    function isCustomROI(){
      return document.querySelector('input[name="roiMode"]:checked')?.value === "custom";
    }
    function roiEnabled(){ return $("toggleROI").checked; }
    function roiLocked(){ return $("toggleLockROI").checked; }

    function updateRoiText(which, n){
      const el = which===1 ? $("roi1Text") : $("roi2Text");
      if(!n){ el.textContent = "-"; return; }
      const f = (x)=> (Math.round(x*1000)/1000).toFixed(3);
      el.textContent = `x=${f(n.nx)} y=${f(n.ny)} w=${f(n.nw)} h=${f(n.nh)}`;
    }

    function setROIBox(which){
      const box = which===1 ? $("roi1") : $("roi2");
      const st = roiState[which];

      if(!roiEnabled() || !st.active){
        box.style.display = "none";
        updateRoiText(which, null);
        return;
      }
      box.style.display = "block";
      box.style.left = st.x + "px";
      box.style.top  = st.y + "px";
      box.style.width  = st.w + "px";
      box.style.height = st.h + "px";

      const stage = which===1 ? $("stage1") : $("stage2");
      const rect = stage.getBoundingClientRect();
      const nx = (st.x / rect.width);
      const ny = (st.y / rect.height);
      const nw = (st.w / rect.width);
      const nh = (st.h / rect.height);
      updateRoiText(which, {nx,ny,nw,nh});
    }

    function attachROI(stageId, which){
      const stage = $(stageId);
      const box = which===1 ? $("roi1") : $("roi2");
      const st = roiState[which];

      const getPos = (e)=>{
        const r = stage.getBoundingClientRect();
        const x = clamp(e.clientX - r.left, 0, r.width);
        const y = clamp(e.clientY - r.top, 0, r.height);
        return {x,y,w:r.width,h:r.height};
      };

      stage.addEventListener("mousedown", (e)=>{
        if(!roiEnabled() || !isCustomROI()) return;

        const p = getPos(e);

        // click inside ROI => move
        if(st.active){
          const within =
            p.x >= st.x && p.x <= st.x + st.w &&
            p.y >= st.y && p.y <= st.y + st.h;
          if(within){
            st.moving = true;
            st.moveDX = p.x - st.x;
            st.moveDY = p.y - st.y;
            return;
          }

          // Lock size ON: click outside -> move ROI (keep size)
          if(roiLocked()){
            st.moving = true;
            st.moveDX = st.w/2;
            st.moveDY = st.h/2;
            st.x = clamp(p.x - st.moveDX, 0, p.w - st.w);
            st.y = clamp(p.y - st.moveDY, 0, p.h - st.h);
            setROIBox(which);
            return;
          }
        }

        // start drawing ROI (only if not locked or not active)
        if(roiLocked() && st.active) return;

        st.drawing = true;
        st.active = true;
        st.startX = p.x;
        st.startY = p.y;
        st.x = p.x; st.y = p.y; st.w = 0; st.h = 0;
        setROIBox(which);
      });

      window.addEventListener("mousemove", (e)=>{
        if(!roiEnabled() || !isCustomROI()) return;

        const p = getPos(e);

        if(st.drawing){
          const x1 = st.startX, y1 = st.startY;
          const x2 = p.x, y2 = p.y;
          st.x = Math.min(x1,x2);
          st.y = Math.min(y1,y2);
          st.w = Math.abs(x2-x1);
          st.h = Math.abs(y2-y1);
          if(st.w < 6) st.w = 6;
          if(st.h < 6) st.h = 6;
          setROIBox(which);
        }else if(st.moving){
          st.x = clamp(p.x - st.moveDX, 0, p.w - st.w);
          st.y = clamp(p.y - st.moveDY, 0, p.h - st.h);
          setROIBox(which);
        }
      });

      window.addEventListener("mouseup", ()=>{
        st.drawing = false;
        st.moving = false;
      });

      box.addEventListener("mousedown", (e)=>{
        if(!roiEnabled() || !isCustomROI()) return;
        e.stopPropagation();
        const p = getPos(e);
        st.moving = true;
        st.moveDX = p.x - st.x;
        st.moveDY = p.y - st.y;
      });
    }

    function applyRoiCursor(){
      [$("stage1"), $("stage2")].forEach(s=>{
        if(roiEnabled() && isCustomROI() && !(roiLocked())) s.classList.add("draw-cursor");
        else s.classList.remove("draw-cursor");
      });
    }

    // Copy ROI1 -> ROI2 size (normalized)
    function copyRoiSize12(){
      const s1 = roiState[1];
      if(!s1.active){
        alert("ROI1 ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏£‡∏≠‡∏ö‡∏Ñ‡∏£‡∏±‡∏ö (‡∏•‡∏≤‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ROI ‡πÉ‡∏ô Picture 1 ‡∏Å‡πà‡∏≠‡∏ô)");
        return;
      }
      const stage1 = $("stage1");
      const stage2 = $("stage2");
      const r1 = stage1.getBoundingClientRect();
      const r2 = stage2.getBoundingClientRect();

      const nw = s1.w / r1.width;
      const nh = s1.h / r1.height;

      const s2 = roiState[2];
      s2.active = true;
      s2.w = Math.max(6, Math.round(nw * r2.width));
      s2.h = Math.max(6, Math.round(nh * r2.height));
      s2.x = Math.round((r2.width - s2.w) / 2);
      s2.y = Math.round((r2.height - s2.h) / 2);
      setROIBox(2);
    }

    // ===========================
    //  Preset Save/Load (localStorage)
    // ===========================
    function normROI(which){
      const st = roiState[which];
      const stage = which===1 ? $("stage1") : $("stage2");
      const r = stage.getBoundingClientRect();
      if(!st.active) return null;
      return {
        nx: st.x / r.width,
        ny: st.y / r.height,
        nw: st.w / r.width,
        nh: st.h / r.height
      };
    }

    function applyNormROI(which, n){
      const stage = which===1 ? $("stage1") : $("stage2");
      const r = stage.getBoundingClientRect();
      const st = roiState[which];
      if(!n){
        st.active = false;
        setROIBox(which);
        return;
      }
      st.active = true;
      st.w = Math.max(6, Math.round(n.nw * r.width));
      st.h = Math.max(6, Math.round(n.nh * r.height));
      st.x = clamp(Math.round(n.nx * r.width), 0, r.width - st.w);
      st.y = clamp(Math.round(n.ny * r.height), 0, r.height - st.h);
      setROIBox(which);
    }

    function presetKey(){
      const k = ($("presetKey").value || "").trim();
      return k ? `smarteye_preset::${k}` : "";
    }

    function presetMsg(t){ $("presetMsg").textContent = t; }

    function savePreset(){
      const k = presetKey();
      if(!k){
        presetMsg("‚ùó ‡πÉ‡∏™‡πà key ‡∏Å‡πà‡∏≠‡∏ô ‡πÄ‡∏ä‡πà‡∏ô: TCRB-COR1 | JOB123 | ABC");
        return;
      }
      const payload = {
        ts: Date.now(),
        lock: roiLocked(),
        roi1: normROI(1),
        roi2: normROI(2)
      };
      localStorage.setItem(k, JSON.stringify(payload));
      presetMsg(`‚úÖ Saved: ${k.replace("smarteye_preset::","")} (${nowStamp()})`);
    }

    function loadPreset(){
      const k = presetKey();
      if(!k){
        presetMsg("‚ùó ‡πÉ‡∏™‡πà key ‡∏Å‡πà‡∏≠‡∏ô");
        return;
      }
      const raw = localStorage.getItem(k);
      if(!raw){
        presetMsg("‡πÑ‡∏°‡πà‡∏û‡∏ö preset ‡∏ô‡∏µ‡πâ");
        return;
      }
      const payload = JSON.parse(raw);
      $("toggleLockROI").checked = !!payload.lock;
      applyNormROI(1, payload.roi1);
      applyNormROI(2, payload.roi2);
      applyRoiCursor();
      presetMsg(`üì• Loaded: ${k.replace("smarteye_preset::","")} (${new Date(payload.ts).toLocaleString()})`);
    }

    function delPreset(){
      const k = presetKey();
      if(!k){
        presetMsg("‚ùó ‡πÉ‡∏™‡πà key ‡∏Å‡πà‡∏≠‡∏ô");
        return;
      }
      localStorage.removeItem(k);
      presetMsg(`üóëÔ∏è Deleted: ${k.replace("smarteye_preset::","")}`);
    }

    // ===========================
    //  Compare Engine (Capture + Realtime)
    //  Features:
    //    - Heatmap overlay
    //    - Auto Align (dx/dy translation)
    //    - Smoothing
    // ===========================
    const rt = {
      w: 320, h: 210,
      cBase: document.createElement("canvas"),
      cLive: document.createElement("canvas"),
      cDiff: document.createElement("canvas"),
      q: [],  // smoothing queue
      lastAlign: {dx:0, dy:0},
      on:false,
      raf:null,
      fps:{t0:performance.now(), frames:0}
    };
    rt.cBase.width = rt.w; rt.cBase.height = rt.h;
    rt.cLive.width = rt.w; rt.cLive.height = rt.h;
    rt.cDiff.width = rt.w; rt.cDiff.height = rt.h;

    function isRealtimeMode(){
      return document.querySelector('input[name="mode"]:checked')?.value === "realtime";
    }

    function overlayEnabled(){ return $("toggleOverlay").checked; }
    function heatmapEnabled(){ return $("toggleHeatmap").checked; }
    function alignEnabled(){ return $("toggleAlign").checked; }
    function alignRange(){ return +$("alignRange").value; }
    function smoothN(){ return +$("smoothRange").value; }

    function clearOverlay2(){
      const ov = $("ov2");
      const r = ov.getBoundingClientRect();
      ov.width = Math.max(1, Math.round(r.width));
      ov.height = Math.max(1, Math.round(r.height));
      ov.getContext("2d").clearRect(0,0,ov.width,ov.height);
    }

    // Color map for heatmap (0..255)
    function heatColor(v){
      // v: 0..255 -> blue/cyan -> yellow -> red
      const t = v / 255;
      let r,g,b;
      if(t < 0.33){
        // blue -> cyan
        const k = t/0.33;
        r = 0;
        g = Math.round(160*k + 60);
        b = 255;
      }else if(t < 0.66){
        // cyan -> yellow
        const k = (t-0.33)/0.33;
        r = Math.round(255*k);
        g = 255;
        b = Math.round(255*(1-k));
      }else{
        // yellow -> red
        const k = (t-0.66)/0.34;
        r = 255;
        g = Math.round(255*(1-k));
        b = 0;
      }
      return [r,g,b];
    }

    // Auto Align: search best dx/dy in small space by minimizing SAD
    function findBestShift(baseData, liveData, w, h, maxShift){
      if(maxShift <= 0) return {dx:0, dy:0};

      let best = {dx:0, dy:0};
      let bestScore = Infinity;

      // sample step to speed
      const step = 2; // skip pixels
      for(let dy=-maxShift; dy<=maxShift; dy++){
        for(let dx=-maxShift; dx<=maxShift; dx++){
          let score = 0;
          let cnt = 0;

          const x0 = Math.max(0, dx);
          const y0 = Math.max(0, dy);
          const x1 = Math.min(w, w+dx);
          const y1 = Math.min(h, h+dy);

          for(let y=y0; y<y1; y+=step){
            let row = y*w;
            let row2 = (y-dy)*w;
            for(let x=x0; x<x1; x+=step){
              const i = ((row + x) << 2);
              const j = ((row2 + (x-dx)) << 2);

              const dr = Math.abs(baseData[i] - liveData[j]);
              const dg = Math.abs(baseData[i+1] - liveData[j+1]);
              const db = Math.abs(baseData[i+2] - liveData[j+2]);
              score += (dr+dg+db);
              cnt++;
            }
          }
          score = score / Math.max(1,cnt);

          if(score < bestScore){
            bestScore = score;
            best = {dx, dy};
          }
        }
      }
      return best;
    }

    function pushSmooth(val){
      const N = smoothN();
      rt.q.push(val);
      while(rt.q.length > N) rt.q.shift();
      const avg = rt.q.reduce((a,b)=>a+b,0)/rt.q.length;
      return avg;
    }

    function computeAndOverlay(baseImg, liveSource, useVideo){
      // baseImg: HTMLImageElement (Picture1)
      // liveSource: HTMLVideoElement or HTMLImageElement (Picture2)
      // useVideo: boolean
      const stage2 = $("stage2");

      const bW = baseImg.naturalWidth || 1280;
      const bH = baseImg.naturalHeight || 720;
      const vW = useVideo ? (liveSource.videoWidth || 1280) : (liveSource.naturalWidth || 1280);
      const vH = useVideo ? (liveSource.videoHeight || 720) : (liveSource.naturalHeight || 720);

      // choose ROI for stage2 (if enabled and ROI2 active), else full
      const useROI = roiEnabled() && roiState[2].active;
      let roiV = {mx:0,my:0,mw:vW,mh:vH};
      let roiB = {mx:0,my:0,mw:bW,mh:bH};

      if(useROI){
        const r2 = roiState[2];
        const roiVid = stageRoiToMediaRoi(stage2, {x:r2.x,y:r2.y,w:r2.w,h:r2.h}, vW, vH);
        roiV = roiVid;
        // apply same normalized ROI to base
        const nx = roiVid.mx / vW;
        const ny = roiVid.my / vH;
        const nw = roiVid.mw / vW;
        const nh = roiVid.mh / vH;
        roiB = {mx:nx*bW, my:ny*bH, mw:nw*bW, mh:nh*bH};
      }

      // draw ROI into small canvases
      const ctxB = rt.cBase.getContext("2d");
      const ctxL = rt.cLive.getContext("2d");
      ctxB.clearRect(0,0,rt.w,rt.h);
      ctxL.clearRect(0,0,rt.w,rt.h);

      ctxB.drawImage(baseImg, roiB.mx, roiB.my, roiB.mw, roiB.mh, 0,0, rt.w,rt.h);
      ctxL.drawImage(liveSource, roiV.mx, roiV.my, roiV.mw, roiV.mh, 0,0, rt.w,rt.h);

      const idB = ctxB.getImageData(0,0,rt.w,rt.h);
      const idL = ctxL.getImageData(0,0,rt.w,rt.h);

      // align dx/dy
      let shift = {dx:0, dy:0};
      if(alignEnabled()){
        const maxS = alignRange();
        shift = findBestShift(idB.data, idL.data, rt.w, rt.h, maxS);
      }
      rt.lastAlign = shift;
      $("alignText").textContent = `dx=${shift.dx} dy=${shift.dy}`;

      // compute diff + overlay mask
      const thr = thrFromSensitivity(+$("sensRange").value);
      $("thrText").textContent = thr;

      const d = idB.data;
      const e = idL.data;

      const out = rt.cDiff.getContext("2d").createImageData(rt.w, rt.h);
      const o = out.data;

      let changed = 0;
      const total = rt.w * rt.h;

      // compare with alignment: compare base(x,y) vs live(x-dx,y-dy)
      for(let y=0; y<rt.h; y++){
        for(let x=0; x<rt.w; x++){
          const xi = x - shift.dx;
          const yi = y - shift.dy;

          const idx = ((y*rt.w + x) << 2);
          if(xi < 0 || yi < 0 || xi >= rt.w || yi >= rt.h){
            o[idx+3] = 0;
            continue;
          }
          const jdx = ((yi*rt.w + xi) << 2);

          const dr = Math.abs(d[idx]   - e[jdx]);
          const dg = Math.abs(d[idx+1] - e[jdx+1]);
          const db = Math.abs(d[idx+2] - e[jdx+2]);
          const diff = (dr+dg+db)/3;

          if(diff > thr){
            changed++;
            if(heatmapEnabled()){
              const [r,g,b] = heatColor(diff);
              o[idx] = r; o[idx+1] = g; o[idx+2] = b; o[idx+3] = 180;
            }else{
              // binary cyan
              o[idx] = 0; o[idx+1] = 229; o[idx+2] = 255; o[idx+3] = 160;
            }
          }else{
            o[idx+3] = 0;
          }
        }
      }

      const diffPct = (changed/total)*100;
      $("diffText").textContent = diffPct.toFixed(2);

      const sm = pushSmooth(diffPct);
      $("diffSmoothText").textContent = sm.toFixed(2);

      const failLimit = +$("failRange").value;
      $("resultText").textContent = (sm > failLimit) ? "FAIL" : "PASS";

      if(overlayEnabled()){
        drawOverlayToStage2(out);
      }else{
        clearOverlay2();
      }

      return {diffPct, diffSmooth: sm, thr, shift, useROI};
    }

    function drawOverlayToStage2(maskSmall){
      const ov = $("ov2");
      const stage2 = $("stage2");
      const rr = stage2.getBoundingClientRect();
      const W = Math.max(1, Math.round(rr.width));
      const H = Math.max(1, Math.round(rr.height));

      if(ov.width !== W || ov.height !== H){
        ov.width = W; ov.height = H;
      }
      const octx = ov.getContext("2d");
      octx.clearRect(0,0,W,H);

      const tmp = document.createElement("canvas");
      tmp.width = rt.w; tmp.height = rt.h;
      tmp.getContext("2d").putImageData(maskSmall,0,0);

      const useROI = roiEnabled() && roiState[2].active;

      octx.save();
      octx.globalCompositeOperation = "lighter";
      octx.imageSmoothingEnabled = false;

      if(useROI){
        const r2 = roiState[2];
        octx.drawImage(tmp, r2.x, r2.y, r2.w, r2.h);

        // neon stroke + glow
        octx.strokeStyle = "rgba(0,229,255,.85)";
        octx.lineWidth = 2;
        octx.shadowColor = "rgba(0,229,255,.55)";
        octx.shadowBlur = 18;
        octx.strokeRect(r2.x+1, r2.y+1, r2.w-2, r2.h-2);
      }else{
        octx.drawImage(tmp, 0,0, W,H);
      }
      octx.restore();

      // Iron-man scanline in overlay
      const t = (Date.now()/1000);
      const y = (Math.sin(t*2.2)*0.5+0.5) * H;
      octx.save();
      octx.globalCompositeOperation = "lighter";
      octx.fillStyle = "rgba(0,229,255,.10)";
      octx.fillRect(0, y-6, W, 12);
      octx.restore();
    }

    // ===========================
    //  Capture Compare (button)
    // ===========================
    function compareCaptureOnce(){
      const base = $("img1");
      if(!base.src){
        alert("Picture 1 ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏†‡∏≤‡∏û‡∏ê‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô (Upload/Capture)");
        return;
      }
      const mode = isRealtimeMode();
      if(mode){
        alert("‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà Realtime Mode ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡∏î‡∏π overlay ‡πÑ‡∏î‡πâ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ)");
        return;
      }

      // target source: prefer img2 if exists, else video2 if live
      const img2 = $("img2");
      const vid2 = $("vid2");
      if(img2.src){
        computeAndOverlay(base, img2, false);
      }else if(streams[2] && vid2.style.display !== "none"){
        computeAndOverlay(base, vid2, true);
      }else{
        alert("Picture 2 ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏û/‡∏Å‡∏•‡πâ‡∏≠‡∏á (Upload/Capture/Open Cam)");
      }
    }

    // ===========================
    //  Realtime loop
    // ===========================
    function startRealtimeCompare(){
      if(rt.on) return;
      rt.on = true;
      rt.q = [];
      rt.fps = {t0:performance.now(), frames:0};
      loopRealtime();
    }
    function stopRealtimeCompare(){
      rt.on = false;
      if(rt.raf) cancelAnimationFrame(rt.raf);
      rt.raf = null;
      rt.q = [];
      clearOverlay2();
    }

    function updateFPS(){
      rt.fps.frames++;
      const t = performance.now();
      const dt = (t - rt.fps.t0)/1000;
      if(dt >= 1){
        const fps = rt.fps.frames/dt;
        $("fpsText").textContent = fps.toFixed(0);
        rt.fps.t0 = t;
        rt.fps.frames = 0;
      }
    }

    function loopRealtime(){
      if(!rt.on){ stopRealtimeCompare(); return; }

      updateFPS();

      const base = $("img1");
      if(!base.src){
        $("resultText").textContent = "NO BASE IMG1";
        $("diffText").textContent = "--";
        $("diffSmoothText").textContent = "--";
        rt.raf = requestAnimationFrame(loopRealtime);
        return;
      }

      const vid2 = $("vid2");
      if(!streams[2] || vid2.style.display==="none"){
        $("resultText").textContent = "OPEN CAM P2";
        $("diffText").textContent = "--";
        $("diffSmoothText").textContent = "--";
        rt.raf = requestAnimationFrame(loopRealtime);
        return;
      }

      computeAndOverlay(base, vid2, true);

      rt.raf = requestAnimationFrame(loopRealtime);
    }

    // ===========================
    //  Export Report (PNG)
    // ===========================
    async function getP2SnapshotDataURL(){
      // prefer img2 if user captured/uploaded, else snapshot from video2
      const img2 = $("img2");
      if(img2.src) return img2.src;

      const vid2 = $("vid2");
      if(streams[2] && vid2.style.display !== "none"){
        const c = document.createElement("canvas");
        c.width = vid2.videoWidth || 1280;
        c.height = vid2.videoHeight || 720;
        c.getContext("2d").drawImage(vid2,0,0,c.width,c.height);
        return c.toDataURL("image/png");
      }
      return "";
    }

    function drawRoiRectOnCanvas(ctx, x,y,w,h, color){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.shadowColor = color;
      ctx.shadowBlur = 12;
      ctx.strokeRect(x,y,w,h);
      ctx.restore();
    }

    async function exportReport(){
      const base = $("img1");
      if(!base.src){
        alert("Picture 1 ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏†‡∏≤‡∏û‡∏ê‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô");
        return;
      }
      const p2url = await getP2SnapshotDataURL();
      if(!p2url){
        alert("Picture 2 ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏û/‡∏Å‡∏•‡πâ‡∏≠‡∏á");
        return;
      }

      // make report canvas
      const W = 1600, H = 900;
      const c = document.createElement("canvas");
      c.width = W; c.height = H;
      const ctx = c.getContext("2d");

      // background
      ctx.fillStyle = "#02040c";
      ctx.fillRect(0,0,W,H);

      // header bar
      ctx.fillStyle = "rgba(0,229,255,.10)";
      ctx.fillRect(0,0,W,90);
      ctx.strokeStyle = "rgba(0,229,255,.35)";
      ctx.strokeRect(18,18,W-36,54);

      ctx.fillStyle = "rgba(234,246,255,.92)";
      ctx.font = "bold 26px ui-monospace, Menlo, Consolas";
      ctx.fillText("SMART EYE HUD ¬∑ INSPECTION REPORT", 40, 54);

      ctx.fillStyle = "rgba(234,246,255,.70)";
      ctx.font = "16px ui-monospace, Menlo, Consolas";
      ctx.fillText(`Timestamp: ${nowStamp()}`, 40, 78);

      // metrics
      const diff = $("diffText").textContent;
      const diffS = $("diffSmoothText").textContent;
      const res = $("resultText").textContent;
      const thr = $("thrText").textContent;
      const align = $("alignText").textContent;
      ctx.fillStyle = "rgba(234,246,255,.78)";
      ctx.fillText(`Diff: ${diff}% | Smooth: ${diffS}% | Result: ${res} | Thr: ${thr} | ${align}`, 540, 78);

      // load images
      const imgBase = await loadImage(base.src);
      const imgP2 = await loadImage(p2url);

      // layout
      const pad = 40;
      const boxW = (W - pad*3) / 2;
      const boxH = 660;
      const y0 = 120;

      // draw panels
      ctx.strokeStyle = "rgba(0,229,255,.25)";
      ctx.strokeRect(pad, y0, boxW, boxH);
      ctx.strokeRect(pad*2 + boxW, y0, boxW, boxH);

      ctx.fillStyle = "rgba(234,246,255,.70)";
      ctx.font = "bold 18px ui-monospace, Menlo, Consolas";
      ctx.fillText("PICTURE 1 (BASE)", pad, y0-12);
      ctx.fillText("PICTURE 2 (TARGET)", pad*2 + boxW, y0-12);

      // draw images contain-fit
      drawContain(ctx, imgBase, pad, y0, boxW, boxH);
      drawContain(ctx, imgP2,   pad*2 + boxW, y0, boxW, boxH);

      // ROI in report: use normalized ROI (from stage) then map to report box area
      const r1n = normROI(1);
      const r2n = normROI(2);
      if(r1n){
        drawRoiRectOnCanvas(ctx,
          pad + r1n.nx*boxW,
          y0  + r1n.ny*boxH,
          r1n.nw*boxW,
          r1n.nh*boxH,
          "rgba(0,229,255,.95)"
        );
      }
      if(r2n){
        drawRoiRectOnCanvas(ctx,
          (pad*2 + boxW) + r2n.nx*boxW,
          y0 + r2n.ny*boxH,
          r2n.nw*boxW,
          r2n.nh*boxH,
          "rgba(255,230,0,.95)"
        );
      }

      // overlay snapshot: take current ov2 and draw over Picture2
      if(overlayEnabled()){
        const ov2 = $("ov2");
        // copy overlay at current display resolution into image
        const ovData = ov2.toDataURL("image/png");
        const ovImg = await loadImage(ovData);
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = 0.95;
        ctx.drawImage(ovImg, pad*2 + boxW, y0, boxW, boxH);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
      }

      // footer
      ctx.fillStyle = "rgba(234,246,255,.55)";
      ctx.font = "14px ui-monospace, Menlo, Consolas";
      ctx.fillText("Generated by SmartEye HUD (HTML) ¬∑ ROI preset stored in browser localStorage", 40, 850);

      // download
      const outUrl = c.toDataURL("image/png");
      downloadDataURL(outUrl, `SmartEye_Report_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`);
    }

    function drawContain(ctx, img, x,y,w,h){
      const arI = img.width / img.height;
      const arB = w / h;
      let dw, dh, dx, dy;
      if(arI > arB){
        dw = w;
        dh = w / arI;
        dx = x;
        dy = y + (h-dh)/2;
      }else{
        dh = h;
        dw = h * arI;
        dy = y;
        dx = x + (w-dw)/2;
      }
      ctx.drawImage(img, dx,dy,dw,dh);
    }

    function loadImage(src){
      return new Promise((resolve, reject)=>{
        const im = new Image();
        im.onload = ()=>resolve(im);
        im.onerror = reject;
        im.crossOrigin = "anonymous";
        im.src = src;
      });
    }

    function downloadDataURL(dataURL, filename){
      const a = document.createElement("a");
      a.href = dataURL;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    // ===========================
    //  UI bindings
    // ===========================
    const failRange = $("failRange");
    const sensRange = $("sensRange");
    const smoothRange = $("smoothRange");
    const alignR = $("alignRange");

    function syncLabels(){
      $("failVal").textContent = `${(+failRange.value).toFixed(1)}%`;
      $("sensVal").textContent = `${sensRange.value}%`;
      $("smoothVal").textContent = `${smoothRange.value}`;
      $("alignRangeVal").textContent = `${alignR.value}`;
      $("thrText").textContent = `${thrFromSensitivity(+sensRange.value)}`;
    }
    [failRange, sensRange, smoothRange, alignR].forEach(r => r.addEventListener("input", syncLabels));
    syncLabels();

    // Compare / Export / Reset
    $("btnCompare").addEventListener("click", compareCaptureOnce);
    $("btnExport").addEventListener("click", exportReport);

    $("btnReset").addEventListener("click", ()=>{
      failRange.value = 10;
      sensRange.value = 60;
      smoothRange.value = 8;
      alignR.value = 8;

      $("toggleROI").checked = true;
      $("toggleLockROI").checked = false;
      $("toggleOverlay").checked = true;
      $("toggleHeatmap").checked = true;
      $("toggleAlign").checked = true;

      $("diffText").textContent = "--";
      $("diffSmoothText").textContent = "--";
      $("resultText").textContent = "-";
      $("alignText").textContent = "dx=0 dy=0";
      rt.q = [];
      clearOverlay2();
      syncLabels();

      [1,2].forEach(k=>{
        roiState[k].active=false;
        setROIBox(k);
      });
      applyRoiCursor();
    });

    // Mode change
    document.querySelectorAll('input[name="mode"]').forEach(r=>{
      r.addEventListener("change", ()=>{
        setModeText();
        if(isRealtimeMode()){
          startRealtimeCompare();
        }else{
          stopRealtimeCompare();
        }
      });
    });
    setModeText();

    // ROI switches
    document.querySelectorAll('input[name="roiMode"]').forEach(r=>{
      r.addEventListener("change", ()=>{
        applyRoiCursor();
      });
    });
    $("toggleROI").addEventListener("change", ()=>{
      [1,2].forEach(k=>setROIBox(k));
      applyRoiCursor();
    });
    $("toggleLockROI").addEventListener("change", ()=>{
      applyRoiCursor();
    });

    // Copy ROI
    $("btnCopyROI12").addEventListener("click", copyRoiSize12);

    // Preset buttons
    $("btnPresetSave").addEventListener("click", savePreset);
    $("btnPresetLoad").addEventListener("click", loadPreset);
    $("btnPresetDel").addEventListener("click", delPreset);

    // Overlay toggle => clear when off
    $("toggleOverlay").addEventListener("change", ()=>{
      if(!overlayEnabled()) clearOverlay2();
    });

    // Camera buttons
    $("openCam1").addEventListener("click", ()=>openCamera(1));
    $("openCam2").addEventListener("click", ()=>openCamera(2));
    $("cap1").addEventListener("click", ()=>captureFrame(1));
    $("cap2").addEventListener("click", ()=>captureFrame(2));
    $("up1").addEventListener("change", (e)=>loadLocalImage(e.target.files?.[0], 1));
    $("up2").addEventListener("change", (e)=>loadLocalImage(e.target.files?.[0], 2));

    // Attach ROI
    attachROI("stage1", 1);
    attachROI("stage2", 2);
    applyRoiCursor();

    // keep overlay canvas in sync on resize
    const ro = new ResizeObserver(()=>clearOverlay2());
    ro.observe($("stage2"));

    // Permission check (best-effort)
    async function checkPermission(){
      try{
        if(!navigator.permissions){
          $("permText").textContent = "Camera: (permissions API not available)";
          $("permHint").textContent = "PERMISSION: UNKNOWN";
          return;
        }
        const res = await navigator.permissions.query({ name: "camera" });
        $("permText").textContent = `Camera: ${res.state}`;
        $("permHint").textContent = `PERMISSION: ${res.state.toUpperCase()}`;
        res.onchange = ()=>{
          $("permText").textContent = `Camera: ${res.state}`;
          $("permHint").textContent = `PERMISSION: ${res.state.toUpperCase()}`;
        };
      }catch{
        $("permText").textContent = "Camera: (cannot query permission)";
        $("permHint").textContent = "PERMISSION: UNKNOWN";
      }
    }
    checkPermission();

    // Auto start realtime if already selected
    if(isRealtimeMode()) startRealtimeCompare();

    // stop camera on exit
    window.addEventListener("beforeunload", ()=>{
      stopCamera(1); stopCamera(2);
    });
  </script>
</body>
</html>
